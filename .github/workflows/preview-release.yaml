# ===========================================================================
# Helm Chart Preview Release Pipeline
# ===========================================================================
#
# This workflow creates a preview release for the helm chart when chart-related
# changes are merged to main. It has MULTI-LAYER loop prevention to avoid
# triggering itself or conflicting with service preview pipelines.
#
# What it does:
# 1. Checks if commit is from ANY preview release pipeline (LOOP PREVENTION)
# 2. Fetches current sprint version from VG Console API
# 3. Calculates next preview version based on existing tags
# 4. Updates Chart.yaml with new version
# 5. Commits the Chart.yaml change back to main
# 6. Creates a tag on the repository
# 7. Creates a GitHub pre-release
# 8. Submits changelog entry to VG Console API (for release changelog aggregation)
#
# ===========================================================================
# LOOP PREVENTION STRATEGY (Multiple Layers)
# ===========================================================================
# Layer 1 (Trigger): Path filter excludes values.yaml (service-only changes)
# Layer 2 (Job): Commit message regex - skips "Preview release X.X.X-Y: ..."
# Layer 3 (Job): Author check - skips automation users:
#   - "cognigy-bypass-branch-protection" (GitHub App that creates commits)
#   - "Voice Gateway CI" (git config name)
#   - Any user ending with "[bot]"
#
# This prevents:
# - This workflow triggering itself (Layer 2 + Layer 3 catch own commits)
# - Service preview pipelines triggering this (Layer 1 + Layer 2 + Layer 3)
# - Race conditions between concurrent releases (retry logic in update job)
# ===========================================================================
#
# ===========================================================================
# REQUIRED SECRETS:
# - VG_CONSOLE_API_BASE_URL: Base URL for VG Console API
# - VG_CONSOLE_API_TOKEN: API token for VG Console changelog submission
# - VG_RELEASE_APP_ID: GitHub App ID for release operations
# - VG_RELEASE_APP_PRIVATE_KEY: GitHub App private key
# - BYPASS_BRANCH_PROTECTION_APP_ID: App ID for branch protection bypass
# - BYPASS_BRANCH_PROTECTION_PRIVATE_KEY: Private key for branch protection
# ===========================================================================

name: Preview Release

on:
  push:
    branches:
      - main
    # Layer 1 of loop prevention: Ignore values.yaml (services only update this)
    # This reduces unnecessary workflow runs when services push preview releases
    paths-ignore:
      - 'values.yaml'
  pull_request:
    branches:
      - main
    paths-ignore:
      - 'values.yaml'
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry Run Mode - No changes will be made, only logs"
        type: boolean
        default: true
      skip_github_release:
        description: "Skip GitHub Release creation"
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  repository-projects: read

env:
  # ==========================================================================
  # CONFIGURATION
  # ==========================================================================
  SERVICE_NAME: "vg-helm-chart"
  VG_CI_USER_NAME: "Voice Gateway CI"
  VG_CI_USER_EMAIL: "voice-gateway-ci@cognigy.com"

jobs:
  # ===========================================================================
  # Auto-label pull requests
  # ===========================================================================
  auto_label:
    name: Auto Label PR
    if: github.event_name == 'pull_request'
    uses: cognigy/vg-resources/.github/workflows/reusable-auto-label.yml@main
    with:
      pr_number: ${{ github.event.pull_request.number }}
    secrets: inherit

  # ===========================================================================
  # JOB 1: Check Prerequisites
  # ===========================================================================
  # Validates that the workflow should run:
  # - Skips if commit is from ANY preview release pipeline (service OR helm chart)
  # - For pull_request: forces dry run mode
  # - For push to main: live mode
  # ===========================================================================
  check_prerequisites:
    name: Check Prerequisites
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      dry_run: ${{ steps.check.outputs.dry_run }}
      trigger_sha: ${{ steps.check.outputs.trigger_sha }}
      trigger_pr_number: ${{ steps.check.outputs.trigger_pr_number }}
      skip_reason: ${{ steps.check.outputs.skip_reason }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check if workflow should run
        id: check
        env:
          WORKFLOW_EVENT: ${{ github.event_name }}
          DRY_RUN_INPUT: ${{ inputs.dry_run }}
          COMMIT_AUTHOR_NAME: ${{ github.event.head_commit.author.name }}
        run: |
          set -euo pipefail
          
          echo "Event type: $WORKFLOW_EVENT"
          echo "Commit author: ${COMMIT_AUTHOR_NAME:-unknown}"
          
          # Get the commit message of the triggering commit
          COMMIT_MSG=$(git log -1 --format=%s)
          COMMIT_AUTHOR=$(git log -1 --format=%an)
          echo "Commit message: $COMMIT_MSG"
          echo "Commit author from git: $COMMIT_AUTHOR"
          
          # ===========================================================================
          # LOOP PREVENTION - Multiple layers of protection
          # ===========================================================================
          
          # Layer 1: Check commit message pattern
          # Catches BOTH:
          # - Service pipelines: "Preview release X.X.X-Y: Update <service>"
          # - This workflow: "Preview release X.X.X-Y: Helm chart update"
          if [[ "$COMMIT_MSG" =~ ^Preview\ release\ [0-9]+\.[0-9]+\.[0-9]+-[0-9]+: ]]; then
            echo "::notice::‚úã Commit matches preview release pattern. Skipping to prevent infinite loop."
            echo "::notice::Pattern: 'Preview release X.X.X-Y: ...'"
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "skip_reason=Preview release commit detected: $COMMIT_MSG" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Layer 2: Check commit author (additional safety)
          # Skip if author is our automation user (GitHub App or git config name)
          if [[ "$COMMIT_AUTHOR" == "Voice Gateway CI" ]] || \
             [[ "$COMMIT_AUTHOR" == "cognigy-bypass-branch-protection" ]] || \
             [[ "$COMMIT_AUTHOR" == *"[bot]"* ]]; then
            echo "::notice::‚úã Commit author is automation ($COMMIT_AUTHOR). Skipping to prevent infinite loop."
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "skip_reason=Automation commit from $COMMIT_AUTHOR: $COMMIT_MSG" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # ===========================================================================
          # All checks passed - this is a human commit, proceed with preview release
          # ===========================================================================
          echo "::notice::‚úÖ Human commit detected - proceeding with preview release"
          echo "::notice::  Author: $COMMIT_AUTHOR"
          echo "::notice::  Message: $COMMIT_MSG"
          echo "::notice::  All loop prevention checks passed"
          
          if [[ "$WORKFLOW_EVENT" == "pull_request" ]]; then
            echo "Triggered by pull_request - FORCING DRY RUN MODE for safety"
            echo "::warning::üîç PR trigger detected - Running in DRY RUN mode (no changes will be made)"
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "dry_run=true" >> $GITHUB_OUTPUT
            echo "trigger_sha=${{ github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
            echo "trigger_pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            
          elif [[ "$WORKFLOW_EVENT" == "push" ]]; then
            echo "Triggered by push to main - LIVE MODE"
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
            echo "trigger_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "trigger_pr_number=" >> $GITHUB_OUTPUT
            
          elif [[ "$WORKFLOW_EVENT" == "workflow_dispatch" ]]; then
            echo "Triggered manually via workflow_dispatch"
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "dry_run=${DRY_RUN_INPUT:-true}" >> $GITHUB_OUTPUT
            echo "trigger_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "trigger_pr_number=" >> $GITHUB_OUTPUT
          else
            echo "::error::Unexpected event type: $WORKFLOW_EVENT"
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "skip_reason=Unexpected event type: $WORKFLOW_EVENT" >> $GITHUB_OUTPUT
          fi

      - name: Display dry-run status
        if: steps.check.outputs.should_run == 'true'
        run: |
          if [[ "${{ steps.check.outputs.dry_run }}" == "true" ]]; then
            echo "::warning::üîç DRY RUN MODE ENABLED - No changes will be made"
          fi

      - name: Display skip reason
        if: steps.check.outputs.should_run == 'false'
        run: |
          echo "::notice::Workflow skipped: ${{ steps.check.outputs.skip_reason }}"

  # ===========================================================================
  # JOB 2: Retrieve Sprint Version from VG Console API (Reusable Workflow)
  # ===========================================================================
  retrieve_sprint_version:
    needs: [check_prerequisites]
    if: needs.check_prerequisites.outputs.should_run == 'true'
    uses: cognigy/vg-resources/.github/workflows/reusable-retrieve-sprint-version.yml@main
    secrets:
      VG_CONSOLE_API_BASE_URL: ${{ secrets.VG_CONSOLE_API_BASE_URL }}

  # ===========================================================================
  # JOB 3: Calculate Preview Version
  # ===========================================================================
  # Generates the next preview version based on existing tags.
  # All services and helm chart share the same preview release counter.
  # Format: v2026.3.0-8.20260119170743 -> next would be 2026.3.0-9
  # ===========================================================================
  calculate_preview_version:
    name: Calculate Preview Version
    runs-on: ubuntu-latest
    needs: [check_prerequisites, retrieve_sprint_version]
    outputs:
      preview_version: ${{ steps.calc.outputs.preview_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate next preview version
        id: calc
        env:
          SPRINT_VERSION: ${{ needs.retrieve_sprint_version.outputs.sprint_version }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
        run: |
          set -euo pipefail
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "::notice::[DRY RUN] Calculating preview version (read-only operation)"
          fi
          
          echo "Sprint version: $SPRINT_VERSION"
          
          # Validate sprint version format (YYYY.sprint.patch)
          if [[ ! "$SPRINT_VERSION" =~ ^[0-9]{4}\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid sprint version format: $SPRINT_VERSION"
            echo "Expected format: YYYY.SPRINT.PATCH (e.g., 2025.24.0)"
            exit 1
          fi
          
          # Fetch all tags
          echo "Fetching tags..."
          git fetch --tags
          
          # Find existing preview tags for the current sprint version
          # Format: v2026.3.0-8.20260119170743 (new) or v2026.3.0-8-20260119170743 (old)
          echo "Looking for existing preview tags for sprint version: $SPRINT_VERSION"
          
          # Match tags like v2026.3.0-*.* (preview releases with timestamp, new format)
          # Also match old format v2026.3.0-*-* for backwards compatibility
          EXISTING_TAGS=$(git tag -l "v${SPRINT_VERSION}-*" 2>/dev/null | grep -E "^v${SPRINT_VERSION}-[0-9]+[\.-][0-9]+$" | sort -V || true)
          
          if [[ -z "$EXISTING_TAGS" ]]; then
            echo "No existing preview tags found for $SPRINT_VERSION"
            NEXT_PREVIEW_NUMBER=1
          else
            echo "Existing preview tags:"
            echo "$EXISTING_TAGS"
            
            # Extract preview numbers from tags like v2026.3.0-8.20260119170743 (new) or v2026.3.0-8-20260119170743 (old)
            # Pattern: v<SPRINT_VERSION>-<PREVIEW_NUMBER>.<TIMESTAMP> or v<SPRINT_VERSION>-<PREVIEW_NUMBER>-<TIMESTAMP>
            PREVIEW_NUMBERS=$(echo "$EXISTING_TAGS" | sed -n "s/^v${SPRINT_VERSION}-\([0-9]\+\)[\.-].*$/\1/p" | sort -n)
            
            if [[ -z "$PREVIEW_NUMBERS" ]]; then
              echo "No preview numbers found in tags, starting at 1"
              NEXT_PREVIEW_NUMBER=1
            else
              HIGHEST_NUMBER=$(echo "$PREVIEW_NUMBERS" | tail -1)
              NEXT_PREVIEW_NUMBER=$((HIGHEST_NUMBER + 1))
              echo "Highest existing preview number: $HIGHEST_NUMBER"
            fi
          fi
          
          PREVIEW_VERSION="${SPRINT_VERSION}-${NEXT_PREVIEW_NUMBER}"
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "::notice::[DRY RUN] Calculated preview version: $PREVIEW_VERSION (would be used if not in dry run)"
          else
            echo "Next preview version: $PREVIEW_VERSION"
          fi
          
          echo "preview_version=$PREVIEW_VERSION" >> $GITHUB_OUTPUT

  # ===========================================================================
  # JOB 4: Update Chart Version
  # ===========================================================================
  # Updates Chart.yaml with the new preview version and commits the change
  # ===========================================================================
  update_chart_version:
    name: Update Chart Version
    runs-on: ubuntu-latest
    needs: [check_prerequisites, retrieve_sprint_version, calculate_preview_version]
    outputs:
      chart_version: ${{ steps.update-chart.outputs.chart_version }}
    steps:
      - name: Generate GitHub App token for branch protection bypass
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.BYPASS_BRANCH_PROTECTION_APP_ID }}
          private-key: ${{ secrets.BYPASS_BRANCH_PROTECTION_PRIVATE_KEY }}
          owner: Cognigy
          repositories: vg-helm-chart

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0
          persist-credentials: true

      - name: Update Chart.yaml version
        id: update-chart
        env:
          PREVIEW_VERSION: ${{ needs.calculate_preview_version.outputs.preview_version }}
          APP_VERSION: ${{ needs.retrieve_sprint_version.outputs.version_previous }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
          VG_CI_USER_NAME: ${{ env.VG_CI_USER_NAME }}
          VG_CI_USER_EMAIL: ${{ env.VG_CI_USER_EMAIL }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
        run: |
          set -euo pipefail
          
          echo "::group::Updating Chart.yaml version"
          
          git config --global user.name "$VG_CI_USER_NAME"
          git config --global user.email "$VG_CI_USER_EMAIL"
          
          CHART_PATH="./Chart.yaml"
          
          # Generate timestamp for version
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          CHART_VERSION="${PREVIEW_VERSION}.${TIMESTAMP}"
          
          # Dry run mode - just log what would happen
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "[DRY RUN] Would update Chart.yaml:"
            echo "[DRY RUN]   - Chart.yaml version = $CHART_VERSION"
            if [[ -n "${APP_VERSION:-}" ]]; then
              echo "[DRY RUN]   - Chart.yaml appVersion = $APP_VERSION"
            else
              echo "[DRY RUN]   - Chart.yaml appVersion = (not set, would skip)"
              echo "::warning::[DRY RUN] APP_VERSION not set, would skip appVersion update"
            fi
            echo "chart_version=$CHART_VERSION" >> $GITHUB_OUTPUT
            echo "::notice::[DRY RUN] Would have updated Chart.yaml"
            echo "::endgroup::"
            exit 0
          fi
          
          # Reset-and-reapply with retry loop (in case of concurrent pushes)
          MAX_RETRIES=5
          PUSH_SUCCESS=false
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES"
            
            # Get latest state
            git fetch origin main
            git reset --hard origin/main
            
            # Regenerate timestamp for this attempt
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            CHART_VERSION="${PREVIEW_VERSION}.${TIMESTAMP}"
            
            echo "Updating Chart.yaml version to $CHART_VERSION"
            yq eval ".version = \"$CHART_VERSION\"" -i "$CHART_PATH"
            
            # Update appVersion to the previous full release version
            if [[ -n "${APP_VERSION:-}" ]]; then
              echo "Updating Chart.yaml appVersion to $APP_VERSION"
              yq eval ".appVersion = \"$APP_VERSION\"" -i "$CHART_PATH"
            else
              echo "::warning::APP_VERSION not set, skipping appVersion update"
            fi
            
            # Commit with standardized message format
            # This message format will be caught by loop prevention (Layer 2) if this workflow triggers again
            COMMIT_MSG="Preview release $PREVIEW_VERSION: Helm chart update"
            git add "$CHART_PATH"
            git commit -m "$COMMIT_MSG"
            
            # Try to push
            if git push origin main; then
              echo "Successfully pushed to main on attempt $i"
              echo "chart_version=$CHART_VERSION" >> $GITHUB_OUTPUT
              PUSH_SUCCESS=true
              break
            fi
            
            # Push failed, wait with random delay before retry
            if [[ $i -lt $MAX_RETRIES ]]; then
              DELAY=$(awk "BEGIN {srand(); printf \"%.3f\", 1 + rand() * 4}")
              echo "Push failed (likely race condition), retrying in ${DELAY}s..."
              sleep "$DELAY"
            fi
          done
          
          if [[ "$PUSH_SUCCESS" != "true" ]]; then
            echo "::error::Failed to push to main after $MAX_RETRIES attempts"
            exit 1
          fi
          
          echo "::notice::Successfully updated Chart.yaml with version $CHART_VERSION"
          echo "::endgroup::"

  # ===========================================================================
  # JOB 5: Tag Helm Chart Repository
  # ===========================================================================
  tag_helm_chart:
    name: Tag Helm Chart
    runs-on: ubuntu-latest
    needs: [check_prerequisites, calculate_preview_version, update_chart_version]
    outputs:
      helm_tag: ${{ steps.tag-helm.outputs.helm_tag }}
    steps:
      - name: Generate GitHub App token for branch protection bypass
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.BYPASS_BRANCH_PROTECTION_APP_ID }}
          private-key: ${{ secrets.BYPASS_BRANCH_PROTECTION_PRIVATE_KEY }}
          owner: Cognigy
          repositories: vg-helm-chart

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0
          persist-credentials: true

      - name: Tag repository (timestamp-based)
        id: tag-helm
        env:
          PREVIEW_VERSION: ${{ needs.calculate_preview_version.outputs.preview_version }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
          VG_CI_USER_NAME: ${{ env.VG_CI_USER_NAME }}
          VG_CI_USER_EMAIL: ${{ env.VG_CI_USER_EMAIL }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
        run: |
          set -euo pipefail
          
          echo "::group::Tagging vg-helm-chart (timestamp-based for semver)"
          
          git config --global user.name "$VG_CI_USER_NAME"
          git config --global user.email "$VG_CI_USER_EMAIL"
          
          git fetch --all --tags
          git checkout main
          git pull origin main
          
          # Extract sprint version from PREVIEW_VERSION (format: YYYY.sprint.patch-preview_number)
          SPRINT_VERSION=$(echo "$PREVIEW_VERSION" | sed -n 's/^\([0-9]\{4\}\.[0-9]\+\.[0-9]\+\)-.*$/\1/p')
          
          if [[ -z "$SPRINT_VERSION" ]]; then
            echo "::error::Could not extract sprint version from PREVIEW_VERSION: $PREVIEW_VERSION"
            exit 1
          fi
          
          # Check if any tags with the same preview version prefix already exist
          # This prevents duplicate preview versions when multiple workflows run concurrently
          EXISTING_TAGS=$(git tag -l "v${PREVIEW_VERSION}.*" -l "v${PREVIEW_VERSION}-*" 2>/dev/null || true)
          
          if [[ -n "$EXISTING_TAGS" ]]; then
            echo "::warning::Tags with preview version $PREVIEW_VERSION already exist:"
            echo "$EXISTING_TAGS"
            echo ""
            echo "Recalculating next preview version to avoid duplicates..."
            
            # Recalculate the next preview number based on current tags
            ALL_PREVIEW_TAGS=$(git tag -l "v${SPRINT_VERSION}-*" 2>/dev/null | grep -E "^v${SPRINT_VERSION}-[0-9]+[\.-][0-9]+$" | sort -V || true)
            
            if [[ -z "$ALL_PREVIEW_TAGS" ]]; then
              NEXT_PREVIEW_NUMBER=1
            else
              PREVIEW_NUMBERS=$(echo "$ALL_PREVIEW_TAGS" | sed -n "s/^v${SPRINT_VERSION}-\([0-9]\+\)[\.-].*$/\1/p" | sort -n)
              if [[ -z "$PREVIEW_NUMBERS" ]]; then
                NEXT_PREVIEW_NUMBER=1
              else
                HIGHEST_NUMBER=$(echo "$PREVIEW_NUMBERS" | tail -1)
                NEXT_PREVIEW_NUMBER=$((HIGHEST_NUMBER + 1))
              fi
            fi
            
            PREVIEW_VERSION="${SPRINT_VERSION}-${NEXT_PREVIEW_NUMBER}"
            echo "Recalculated preview version: $PREVIEW_VERSION"
          fi
          
          # Generate timestamp-based tag (for semver auto-deployment)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          TAG_NAME="v${PREVIEW_VERSION}.${TIMESTAMP}"
          
          # Double-check that this exact tag doesn't already exist
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "::error::Tag $TAG_NAME already exists. This should not happen."
            exit 1
          fi
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "[DRY RUN] Would create and push timestamp-based tag:"
            echo "[DRY RUN]   git tag -a $TAG_NAME -m 'Preview release $PREVIEW_VERSION ($SERVICE_NAME)'"
            echo "[DRY RUN]   git push origin $TAG_NAME"
            echo "[DRY RUN] Note: Flux semver will auto-pick this as latest matching tag"
            echo "::notice::[DRY RUN] Would have tagged vg-helm-chart with $TAG_NAME"
          else
            echo "Creating timestamp-based tag $TAG_NAME..."
            git tag -a "$TAG_NAME" -m "Preview release $PREVIEW_VERSION ($SERVICE_NAME)"
            git push origin "$TAG_NAME"
            echo "::notice::Successfully tagged vg-helm-chart with $TAG_NAME"
            echo "Note: Flux semver will auto-pick this as latest matching tag"
          fi
          
          echo "helm_tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "preview_version=$PREVIEW_VERSION" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # ===========================================================================
  # JOB 6: Create GitHub Release
  # ===========================================================================
  create_github_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [check_prerequisites, calculate_preview_version, tag_helm_chart]
    if: |
      always() &&
      inputs.skip_github_release != true &&
      needs.tag_helm_chart.result == 'success'
    outputs:
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
      pr_title: ${{ steps.get-pr.outputs.pr_title }}
      pr_url: ${{ steps.get-pr.outputs.pr_url }}
      pr_author: ${{ steps.get-pr.outputs.pr_author }}
      visibility: ${{ steps.get-pr.outputs.visibility }}
      category: ${{ steps.get-pr.outputs.category }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.VG_RELEASE_APP_ID }}
          private-key: ${{ secrets.VG_RELEASE_APP_PRIVATE_KEY }}
          owner: Cognigy

      - name: Get merged PR information for release notes
        id: get-pr
        uses: actions/github-script@v7
        env:
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
          GRAPHQL_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let pr = null;
            
            // For pull_request events, get PR directly from payload
            if (context.eventName === 'pull_request' && context.payload.pull_request) {
              pr = context.payload.pull_request;
              console.log(`PR from event payload: #${pr.number}: ${pr.title}`);
            } else {
              // For push or workflow_dispatch, look up PR by SHA
              const sha = context.sha;
              console.log(`Looking for PR associated with SHA: ${sha}`);
              
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: sha
              });
              
              if (prs.length > 0) {
                pr = prs[0];
                console.log(`Found PR #${pr.number}: ${pr.title}`);
              }
            }
            
            try {
              if (pr) {
                console.log(`Using PR #${pr.number}: ${pr.title}`);
                core.setOutput('pr_number', pr.number);
                core.setOutput('pr_title', pr.title);
                core.setOutput('pr_url', pr.html_url);
                core.setOutput('pr_body', pr.body || '');
                core.setOutput('pr_author', pr.user?.login || '');
                
                // Extract visibility and category from PR labels
                const labels = (pr.labels || []).map(l => typeof l === 'string' ? l : l.name);
                console.log(`PR labels: ${labels.join(', ')}`);
                
                // Visibility: only public or internal (determines who sees the entry)
                let visibility = 'internal';
                if (labels.includes('changelog:public')) visibility = 'public';
                
                // Category: determines which section the entry appears in
                let category = 'improvement';
                if (labels.includes('type:feature')) category = 'feature';
                else if (labels.includes('type:fix')) category = 'fix';
                else if (labels.includes('type:breaking')) category = 'breaking';
                else if (labels.includes('type:security')) category = 'security';
                else if (labels.includes('type:infrastructure')) category = 'infrastructure';
                
                console.log(`Extracted visibility: ${visibility}, category: ${category}`);
                core.setOutput('visibility', visibility);
                core.setOutput('category', category);
                
                // Fetch linked projects using GraphQL
                try {
                  const primaryToken = process.env.GRAPHQL_TOKEN;
                  const fallbackToken = process.env.APP_TOKEN;
                  
                  const projectsQuery = `
                    query($owner: String!, $repo: String!, $prNumber: Int!) {
                      repository(owner: $owner, name: $repo) {
                        pullRequest(number: $prNumber) {
                          projectItems(first: 10) {
                            nodes {
                              project {
                                id
                                title
                                number
                                url
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  async function fetchProjects(tokenLabel, token) {
                    const graphqlResponse = await fetch('https://api.github.com/graphql', {
                      method: 'POST',
                      headers: {
                        Authorization: `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        Accept: 'application/vnd.github+json',
                        'X-GitHub-Api-Version': '2022-11-28'
                      },
                      body: JSON.stringify({
                        query: projectsQuery,
                        variables: {
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          prNumber: pr.number
                        }
                      })
                    });

                    if (!graphqlResponse.ok) {
                      const errorText = await graphqlResponse.text();
                      throw new Error(`[${tokenLabel}] GraphQL request failed: ${graphqlResponse.status} ${graphqlResponse.statusText} - ${errorText}`);
                    }

                    const projectsResult = await graphqlResponse.json();
                    if (projectsResult.errors?.length) {
                      throw new Error(`[${tokenLabel}] GraphQL errors: ${JSON.stringify(projectsResult.errors)}`);
                    }

                    const projectItems = projectsResult?.data?.repository?.pullRequest?.projectItems?.nodes || [];
                    return projectItems
                      .filter(item => item.project)
                      .map(item => ({
                        title: item.project.title,
                        url: item.project.url
                      }));
                  }

                  let projects = [];
                  if (primaryToken) {
                    try {
                      projects = await fetchProjects('GITHUB_TOKEN', primaryToken);
                    } catch (e) {
                      console.log(`Could not fetch project links with GITHUB_TOKEN: ${e.message}`);
                    }
                  }

                  if (projects.length === 0 && fallbackToken && fallbackToken !== primaryToken) {
                    try {
                      projects = await fetchProjects('APP_TOKEN', fallbackToken);
                    } catch (e) {
                      console.log(`Could not fetch project links with APP_TOKEN: ${e.message}`);
                    }
                  }
                  
                  console.log(`Found ${projects.length} linked project(s):`, projects.map(p => p.title));
                  core.setOutput('projects', JSON.stringify(projects));
                } catch (graphqlError) {
                  console.log(`Could not fetch project links: ${graphqlError.message}`);
                  core.setOutput('projects', '[]');
                }
              } else {
                console.log('No PR found for this commit');
                core.setOutput('pr_number', '');
                core.setOutput('pr_title', '');
                core.setOutput('pr_url', '');
                core.setOutput('pr_body', '');
                core.setOutput('pr_author', '');
                core.setOutput('visibility', 'internal');
                core.setOutput('category', 'improvement');
                core.setOutput('projects', '[]');
              }
            } catch (error) {
              console.log(`Error finding PR: ${error.message}`);
              core.setOutput('pr_number', '');
              core.setOutput('pr_title', '');
              core.setOutput('pr_url', '');
              core.setOutput('pr_body', '');
              core.setOutput('pr_author', '');
              core.setOutput('visibility', 'internal');
              core.setOutput('category', 'improvement');
              core.setOutput('projects', '[]');
            }

      - name: Create GitHub Release
        uses: actions/github-script@v7
        env:
          HELM_TAG: ${{ needs.tag_helm_chart.outputs.helm_tag }}
          PREVIEW_VERSION: ${{ needs.calculate_preview_version.outputs.preview_version }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
          PR_NUMBER: ${{ steps.get-pr.outputs.pr_number }}
          PR_TITLE: ${{ steps.get-pr.outputs.pr_title }}
          PR_URL: ${{ steps.get-pr.outputs.pr_url }}
          PROJECTS: ${{ steps.get-pr.outputs.projects }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const helmTag = process.env.HELM_TAG;
            const previewVersion = process.env.PREVIEW_VERSION;
            const serviceName = process.env.SERVICE_NAME;
            const dryRun = process.env.DRY_RUN === 'true';
            const prNumber = process.env.PR_NUMBER;
            const prTitle = process.env.PR_TITLE;
            const prUrl = process.env.PR_URL;
            const projects = JSON.parse(process.env.PROJECTS || '[]');
            
            if (!helmTag) {
              console.log('No helm tag available, skipping release creation');
              return;
            }
            
            // Build release name
            const releaseName = `${serviceName} v${previewVersion} (Preview)`;
            
            // Build release body
            const buildDate = new Date();
            const formattedDate = buildDate.toLocaleDateString('de-DE', { 
              day: '2-digit', 
              month: '2-digit', 
              year: 'numeric' 
            }) + ' ' + buildDate.toLocaleTimeString('de-DE', { 
              hour: '2-digit', 
              minute: '2-digit' 
            });
            
            let releaseBody = '';
            
            // PR Description - just the link to the PR
            if (prUrl) {
              releaseBody += `## üìù Pull Request\n\n`;
              releaseBody += `### [${prTitle}](${prUrl})\n\n`;
            }
            
            // Helm Chart Info
            releaseBody += `## üì¶ Helm Chart\n\n`;
            releaseBody += `**Version**: \`${helmTag}\`\n`;
            releaseBody += `**Built**: ${formattedDate}\n\n`;
            
            // Include linked projects
            if (projects.length > 0) {
              releaseBody += `## üîó Linked Projects\n\n`;
              projects.forEach(project => {
                if (project.url) {
                  releaseBody += `- [${project.title}](${project.url})\n`;
                } else {
                  releaseBody += `- ${project.title}\n`;
                }
              });
              releaseBody += `\n`;
            }
            
            releaseBody += `---\n\n`;
            releaseBody += `> ‚ö†Ô∏è **This is a preview release** and may contain features that are still in development.\n\n`;
            releaseBody += `*Generated automatically by the helm chart preview release pipeline.*`;
            
            console.log('Release Name:', releaseName);
            console.log('Tag:', helmTag);
            console.log('Release Body Preview (first 500 chars):', releaseBody.substring(0, 500));
            
            if (dryRun) {
              console.log('[DRY RUN] Would create GitHub Release:');
              console.log(`[DRY RUN]   Name: ${releaseName}`);
              console.log(`[DRY RUN]   Tag: ${helmTag}`);
              console.log(`[DRY RUN]   Pre-release: true`);
              console.log(`[DRY RUN]   PR: ${prUrl || 'none'}`);
              console.log(`[DRY RUN]   Linked projects: ${projects.length > 0 ? projects.map(p => p.title).join(', ') : 'none'}`);
              console.log('[DRY RUN] Full release body:');
              console.log(releaseBody);
              core.notice(`[DRY RUN] Would have created GitHub Release: ${releaseName}`);
              return;
            }
            
            try {
              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: helmTag,
                name: releaseName,
                body: releaseBody,
                prerelease: true
              });
              
              console.log(`Created release: ${release.html_url}`);
              core.notice(`Created GitHub Release: ${release.html_url}`);
              
            } catch (error) {
              // If release already exists, that's okay
              if (error.status === 422 && error.message.includes('already_exists')) {
                console.log(`Release for tag ${helmTag} already exists. Skipping.`);
                core.warning(`Release for tag ${helmTag} already exists.`);
              } else {
                console.error(`Error creating release: ${error.message}`);
                core.warning(`Failed to create GitHub Release: ${error.message}`);
              }
            }

  # ===========================================================================
  # JOB 7: Submit Changelog to VG Console API
  # ===========================================================================
  submit_changelog:
    name: Submit Changelog to VG Console
    runs-on: ubuntu-latest
    needs: [check_prerequisites, calculate_preview_version, create_github_release]
    if: |
      always() && needs.create_github_release.result == 'success'
    steps:
      - name: Submit changelog entry to VG Console API
        env:
          VG_CONSOLE_API_BASE_URL: ${{ secrets.VG_CONSOLE_API_BASE_URL }}
          VG_CONSOLE_API_TOKEN: ${{ secrets.VG_CONSOLE_API_TOKEN }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          PREVIEW_VERSION: ${{ needs.calculate_preview_version.outputs.preview_version }}
          PR_NUMBER: ${{ needs.create_github_release.outputs.pr_number }}
          PR_TITLE: ${{ needs.create_github_release.outputs.pr_title }}
          PR_URL: ${{ needs.create_github_release.outputs.pr_url }}
          PR_AUTHOR: ${{ needs.create_github_release.outputs.pr_author }}
          VISIBILITY: ${{ needs.create_github_release.outputs.visibility }}
          CATEGORY: ${{ needs.create_github_release.outputs.category }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
        run: |
          set -euo pipefail
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "::group::[DRY RUN] Changelog Submission Preview"
          else
            echo "::group::Submitting changelog to VG Console API"
          fi
          
          RELEASE_URL="https://github.com/Cognigy/${SERVICE_NAME}/releases/tag/${PREVIEW_VERSION}"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S")
          
          if [[ -n "${PR_NUMBER:-}" && "${PR_NUMBER}" =~ ^[0-9]+$ ]]; then
            PR_NUMBER_JSON="${PR_NUMBER}"
          else
            PR_NUMBER_JSON="null"
          fi
          
          jq -n \
            --arg service "${SERVICE_NAME}" \
            --arg version "${PREVIEW_VERSION}" \
            --arg timestamp "${TIMESTAMP}" \
            --argjson pr_number "${PR_NUMBER_JSON}" \
            --arg pr_title "${PR_TITLE:-}" \
            --arg pr_url "${PR_URL:-}" \
            --arg pr_author "${PR_AUTHOR:-}" \
            --arg release_url "${RELEASE_URL}" \
            --arg visibility "${VISIBILITY:-internal}" \
            --arg category "${CATEGORY:-improvement}" \
            '{
              service: $service,
              version: $version,
              timestamp: $timestamp,
              pr: {
                number: $pr_number,
                title: $pr_title,
                url: $pr_url,
                author: $pr_author
              },
              release: { url: $release_url },
              visibility: $visibility,
              category: $category,
              summary: $pr_title
            }' > changelog_payload.json
          
          echo "üì¶ Changelog Payload:"
          cat changelog_payload.json | jq '.'
          
          if [[ "$DRY_RUN" == "true" ]]; then
            API_BASE_URL="${VG_CONSOLE_API_BASE_URL:-https://console-vg-team-dev.cognigy.dev}"
            echo "[DRY RUN] Would POST to: ${API_BASE_URL}/api/ci/changelog"
            echo "::notice::[DRY RUN] Changelog submission skipped"
            echo "::endgroup::"
            exit 0
          fi
          
          API_BASE_URL="${VG_CONSOLE_API_BASE_URL:-https://console-vg-team-dev.cognigy.dev}"
          API_TOKEN="${VG_CONSOLE_API_TOKEN:-Cognigy2026!}"
          
          HTTP_STATUS=$(curl -X POST \
            "${API_BASE_URL}/api/ci/changelog" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -d @changelog_payload.json \
            -w "%{http_code}" \
            -o response.json \
            -s)
          
          echo "HTTP Status: $HTTP_STATUS"
          
          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            echo "::notice::Successfully submitted changelog to VG Console API"
          else
            echo "::warning::Failed to submit changelog (HTTP $HTTP_STATUS) - continuing anyway"
            if [[ -f response.json ]]; then
              cat response.json
            fi
          fi
          
          echo "::endgroup::"

  # ===========================================================================
  # JOB 8: Release Summary
  # ===========================================================================
  release_summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs:
      - check_prerequisites
      - retrieve_sprint_version
      - calculate_preview_version
      - update_chart_version
      - tag_helm_chart
      - create_github_release
      - submit_changelog
    if: always()
    steps:
      - name: Generate Summary
        env:
          SHOULD_RUN: ${{ needs.check_prerequisites.outputs.should_run }}
          SKIP_REASON: ${{ needs.check_prerequisites.outputs.skip_reason }}
          SPRINT_VERSION: ${{ needs.retrieve_sprint_version.outputs.sprint_version }}
          PREVIEW_VERSION: ${{ needs.calculate_preview_version.outputs.preview_version }}
          DRY_RUN: ${{ needs.check_prerequisites.outputs.dry_run }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          CHART_UPDATE_RESULT: ${{ needs.update_chart_version.result }}
          HELM_TAG_RESULT: ${{ needs.tag_helm_chart.result }}
          HELM_TAG: ${{ needs.tag_helm_chart.outputs.helm_tag }}
          GITHUB_RELEASE_RESULT: ${{ needs.create_github_release.result }}
          SUBMIT_CHANGELOG_RESULT: ${{ needs.submit_changelog.result }}
        run: |
          echo "=============================================="
          echo "   HELM CHART PREVIEW RELEASE SUMMARY"
          echo "=============================================="
          echo ""
          
          if [[ "$SHOULD_RUN" == "false" ]]; then
            echo "‚è≠Ô∏è  SKIPPED: $SKIP_REASON"
            exit 0
          fi
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "üîç MODE: DRY RUN (no changes were made)"
          else
            echo "üöÄ MODE: LIVE RELEASE"
          fi
          echo ""
          echo "üì¶ Service: $SERVICE_NAME"
          echo "üìå Sprint Version: $SPRINT_VERSION"
          echo "üè∑Ô∏è  Preview Version: $PREVIEW_VERSION"
          echo "üè∑Ô∏è  Helm Chart Tag: ${HELM_TAG:-N/A}"
          echo ""
          echo "=============================================="
          echo "              JOB RESULTS"
          echo "=============================================="
          echo "Update Chart:       $CHART_UPDATE_RESULT"
          echo "Tag Helm Chart:     $HELM_TAG_RESULT"
          echo "GitHub Release:     $GITHUB_RELEASE_RESULT"
          echo "Submit Changelog:   $SUBMIT_CHANGELOG_RESULT"
          echo "=============================================="
          echo ""
          echo "üìù Note: Staging deployment is automatic via Flux semver"
          echo "   Flux will auto-pick the latest tag matching >=2026.0.0-0"
          
          # Check for failures
          if [[ "$CHART_UPDATE_RESULT" == "failure" ]] || \
             [[ "$HELM_TAG_RESULT" == "failure" ]]; then
            echo ""
            echo "‚ö†Ô∏è  Some jobs failed. Please review the logs above."
            exit 1
          else
            echo ""
            echo "‚úÖ Helm chart preview release completed successfully!"
          fi