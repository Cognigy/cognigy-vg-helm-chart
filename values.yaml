###########
# General #
###########

global:
  ## Indication that is a Kubernetes deployment
  k8s: true
  ## Node environment
  nodeEnv: ""  
  ## Default local host IP
  localhost: 127.0.0.1
  ## Collect stats variables
  ## Tracking call counts by entity level configuration
  track:
    accountCalls: true
    applicationCalls: true
    serviceProviderCalls: true

###############
# Cognigy ENV #
###############

cognigyEnv:
  ## Enable Redis Sentinel Mode
  ## Note: Redis HA needs to be enabled to use Redis Sentinel Mode
  FEATURE_REDIS_SENTINEL_MODE_ENABLED: "false"
  ## Redis Sentinel Master Name
  REDIS_SENTINEL_MASTER_NAME: "mymaster"
  ## Redis Sentinel Host
  REDIS_SENTINEL_HOST: "redis-ha-headless"
  ## Redis Sentinel Port
  REDIS_SENTINEL_PORT: "26379"

## Credentials for pulling image from private image registry.
## Ref.: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imageCredentials:
  registry: ""
  username: ""
  password: ""
  ## Alternatively specify an array of imagePullSecrets.
  ## Secrets must be manually created in the proper namespace beforehand.
  ## Example:
  ## pullSecrets:
  ##   - cognigyRegistrySecretName
  ##
  ## Note: When registry, username and password are set, the pullSecrets are ignored.
  pullSecrets: []

## We support the 3 major cloud providers: aws, azure, gcp
cloud: ""

aws:
  ## Set to true, if using IMDSv2
  useIMDSv2: true
  grafana:
    storageClassName: "grafana"
    provisionerName: "ebs.csi.aws.com"
    awsEBSVolumeType: "gp3"
  influxdb:
    storageClassName: "influxdb"
    provisionerName: "ebs.csi.aws.com"
    awsEBSVolumeType: "gp3"
  mysql:
    storageClassName: "mysql"
    provisionerName: "ebs.csi.aws.com"
    awsEBSVolumeType: "gp3"
  postgresql:
    storageClassName: "postgres"
    provisionerName: "ebs.csi.aws.com"
    awsEBSVolumeType: "gp3"

azure:
  useLoadBalancerIMDS: true
  grafana:
    storageClassName: "grafana"
    provisionerName: "disk.csi.azure.com"
    azureStorageAccountType: "StandardSSD_LRS"
  influxdb:
    storageClassName: "influxdb"
    provisionerName: "disk.csi.azure.com"
    azureStorageAccountType: "StandardSSD_LRS"
  mysql:
    storageClassName: "mysql"
    provisionerName: "disk.csi.azure.com"
    azureStorageAccountType: "StandardSSD_LRS"
  postgresql:
    storageClassName: "postgres"
    provisionerName: "disk.csi.azure.com"
    azureStorageAccountType: "StandardSSD_LRS"

gcp:
  grafana:
    storageClassName: "grafana"
    provisionerName: "pd.csi.storage.gke.io"
    pdType: "pd-balanced"
  influxdb:
    storageClassName: "influxdb"
    provisionerName: "pd.csi.storage.gke.io"
    pdType: "pd-balanced"
  mysql:
    storageClassName: "mysql"
    provisionerName: "pd.csi.storage.gke.io"
    pdType: "pd-balanced"
  postgresql:
    storageClassName: "postgres"
    provisionerName: "pd.csi.storage.gke.io"
    pdType: "pd-balanced"

stats:
  ## Metrics will be generate
  enabled: true
  ## Connection type
  protocol: tcp
  ## Metrics will be generated in Telegraf format
  telegraf: true
  ## A value from 0 to 1; 1 = send all samples, 0.5 = send every 2nd sample, and so on.
  sampleRate: 1

#######
# TLS #
#######

## Traefik TLS certificate for the hostname defined at ingress.<service_name>.host
## NOTE: If you provide "tls.enable: true" and "traefik.enabled: true", either tls.crt and tls.key or tls.existingSecret must be provided.
tls:
  ## Enable traefik tls
  ## NOTE: If traefik is enabled ("traefik.enabled: true"), and you provide "tls.enable: false", then the auto redirection of http to https
  ## also must be disabled by setting traefik.ports.web.redirectTo: null
  enabled: true
  ## Add Custom CA certificate. A tls type secret named "cognigy-traefik" will be created based on the values of tls.crt and tls.key
  ## Careful with the indentation
  ## For more information, see https://helm.sh/docs/chart_template_guide/yaml_techniques/#strings-in-yaml
  ##
  ## Custom CA certificate in plaintext, not base64 encoded.
  ## Example:
  ##   crt: |
  ##     -----BEGIN CERTIFICATE-----
  ##     -----END CERTIFICATE-----
  crt: ""
  ## CA certificate private key in plaintext, not base64 encoded.
  ## Example:
  ## key: |
  ##   -----BEGIN PRIVATE KEY-----
  ##   -----END PRIVATE KEY-----
  key: ""
  ## Existing secret with TLS certificates. The secret must have the following two keys:
  ## "tls.crt": Containing the CA certificate
  ## "tls.key": Containing the certificate key
  ## NOTE: When tls.existingSecret is set, clear text certificate passed in the previous parameters "tls.crt" and "tls.key" are ignored.
  existingSecret: ""

#############
# Analytics #
#############

cognigyInsights:
  # If enabled, analytics data will be collected and sent to the cognigy insights collector api
  enabled: false
  collectInteractionPanelCalls: false

  # API of service-collectors - VG can send to multiple ai endpoints
  apiUrl: ""
  apiUrlApp: ""
  apiUrlDev: ""
  apiUrlStaging: ""
  apiUrlTrial: ""

  apiKey:
    secret: ""
    secretKey: ""
  apiKeyApp:
    secret: ""
    secretKey: ""
  apiKeyDev:
    secret: ""
    secretKey: ""
  apiKeyStaging:
    secret: ""
    secretKey: ""
  apiKeyTrial:
    secret: ""
    secretKey: ""

# Decoding of JWT Interaction Panels calls require the same secret as used in service-api for encoding
# Supports multiple tokens, seperated by ';' secret1;secret2;
cognigyJwtSecrets:
  secret: ""
  secretKey: ""

###########
# Tracing #
###########

tracing:
  enabled: false
  errorsEnabled: false
  baseUrl: ""
  sampleRate: ""
  eventsSampleRate: ""
  environment: ""
  # enable call tracing with sentry
  callTracingEnabled: false
  apiBaseUrl: ""  
  # sentry project e.g 'vg-dev'
  apiProject: ""
  secret: "vg-sentry-api-token"
  secretKey: token

###########
# Ingress #
###########

## If ingress is not required to deploy then you can set "ingress.enabled" to false.
## By default it is always enabled.
ingress:
  enabled: true
  api:
    host: ""
    ipWhiteListMiddleware:
      enabled: false
      ipWhiteList:
        sourceRange:
          - 0.0.0.0/0
        ipStrategy:
          depth: 0
  billingApp:
    host: ""
    ipWhiteListMiddleware:
      enabled: false
      ipWhiteList:
        sourceRange:
          - 0.0.0.0/0
        ipStrategy:
          depth: 0
  jaeger:
    enabled: false
    host: ""
    basicAuthMiddleware:
      enabled: true
    ipWhiteListMiddleware:
      enabled: false
      ipWhiteList:
        sourceRange:
          - 0.0.0.0/0
        ipStrategy:
          depth: 0
  testCallManager:
    host: ""
    ipWhiteListMiddleware:
      enabled: false
      ipWhiteList:
        sourceRange:
          - 0.0.0.0/0
        ipStrategy:
          depth: 0
  webapp:
    host: ""
    ipWhiteListMiddleware:
      enabled: false
      ipWhiteList:
        sourceRange:
          - 0.0.0.0/0
        ipStrategy:
          depth: 0

#############
# SIP & RTP #
#############

## These values route which nodepool the SBC SIP and RTP pods will be placed in.
## The pods have to be in special nodepools that use host network binding due to the nature
## of sip signaling and the current lack of support for the SIP Protocol in Tngress Controllers.
##
## Note: If you want to put SIP and RTP into a single nodepool (e.g.: to save cost on a smaller deployment),
## then set both labels below to the same value and both tolerations below to the same value,
## and use those values when creating your single edge-facing nodepool when you spin up the cluster.
##
# Remark: For production deployments, separate nodepools are recommended for SIP and RTP.
sbc:
  sip:
    ## The number of replicas for the RTP pods needs to be the same as the number of static IPs provisioned for the media traffic.
    replicaCount: 2
    ## Please set sbc.rtp.useStatefulSet to false if you don't want to use StatefulSet for SBC RTP (headless service).
    ## Setting it to false is not recommended because the media traffic is often not divided between the pods.
    useStatefulSet: false
    headlessServiceName: sbc-sip-headless
    serviceName: sbc-sip
    useAffinityOnDaemonSet: false
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - sbc-sip
            topologyKey: "kubernetes.io/hostname"
    nodeSelector:
      voip-environment: "edge"
    priorityClassName: ""
    podSecurityContext: {}
    tolerations:
      - key: "voip-edge"
        operator: "Exists"
        effect: "NoSchedule"
    logLevel: info
    sofiaLoglevel: "3"
    ports:
      tcp: 5060
      tls: 5061
      udp: 5060
      wss: 8443
  rtp:
    ## The number of replicas for the RTP pods needs to be the same as the number of static IPs provisioned for the media traffic.
    replicaCount: 2
    ## Please set sbc.rtp.useStatefulSet to false if you don't want to use StatefulSet for SBC RTP (headless service).
    ## Setting it to false is not recommended because the media traffic is often not divided between the pods.
    useStatefulSet: false
    headlessServiceName: sbc-rtp-headless
    serviceName: sbc-rtp
    useAffinityOnDaemonSet: false
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - sbc-rtp
            topologyKey: "kubernetes.io/hostname"
    nodeSelector:
      media-environment: "edge"
    priorityClassName: ""
    podSecurityContext: {}
    tolerations:
      - key: "media-edge"
        operator: "Exists"
        effect: "NoSchedule"
    port: 22222
  ## EC2 Static EIP Allocator
  ec2EipAllocator:
    ## Only for AWS
    enabled: false
    image: cognigy.azurecr.io/ec2-eip-allocator:1.1.1
    ## Tag for the SIP EIP Node Pool
    sipEipGroupRole: ""
    ## Tag for the RTP EIP Node Pool
    rtpEipGroupRole: ""
    ## User to reallocate static EIPs
    vgOperatorUser: ""

#############
# Databases #
#############

dbCreate:
  hookEnabled: false
  hook: post-install,pre-upgrade
  image: cognigy.azurecr.io/db-create:release-6c6f917eb3e598f50203f1a991ad79b6a238d808-1700034885
  imagePullPolicy: IfNotPresent
  logCollectorEnabled: false

influxdb:
  image: cognigy.azurecr.io/vg-influx:release-ded56799f93fb2c6035f8a4582b56d7e6d7aaac0-1689255770
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  storage: 20Gi
  storageClassName: influxdb
  logLevel: info
  database:
    name: call_counts
  host: influxdb
  port: 8086
  resources:
    requests:
      cpu: "0.500"
      memory: 750Mi
    limits:
      cpu: "1"
      memory: 1.5Gi

## Bitnami Chart, image info: bitnami/mysql:8.0.34-debian-11-r75
mysql:
  enabled: true
  global:
    imageRegistry: cognigy.azurecr.io
    imagePullSecrets:
      - cognigy-registry-token
    storageClass: mysql
  fullnameOverride: mysql
  auth:
    createDatabase: true
    database: jambones
    username: jambones
    existingSecret: voicegateway-mysql-password
  image:
    repository: mysql
    tag: 8.0.34-debian-11-r75
  primary:
    priorityClassName: ""
    persistence:
      size: "10Gi"
    resources:
      requests:
        cpu: "0.500"
        memory: 2Gi
      limits:
        cpu: "0.500"
        memory: 2Gi
  metrics:
    enabled: true
    image:
      repository: mysqld-exporter
      tag: 0.14.0-debian-11-r116
    resources:
      requests:
        cpu: "0.400"
        memory: 400Mi
      limits:
        cpu: "0.400"
        memory: 400Mi
    serviceMonitor:
      enabled: false
  database:
    name: jambones
  host: mysql
  port: 3306

## Bitnami Chart, image info: bitnami/postgresql:14.9.0-debian-11-r58
## Used only internally by heplify-server and homer to store sip captures
postgresql:
  enabled: true
  global:
    imageRegistry: cognigy.azurecr.io
    imagePullSecrets:
      - cognigy-registry-token
    storageClass: postgres
  fullnameOverride: postgres
  auth:
    postgresUsername: postgres
    postgresPassword: homer7Seven
    database: homer_config
  image:
    repository: postgres
    tag: 14.9.0-debian-11-r58
  primary:
    priorityClassName: ""
    persistence:
      size: "30Gi"
    resources:
      requests:
        cpu: "0.500"
        memory: 3Gi
      limits:
        cpu: "0.500"
        memory: 3Gi
  metrics:
    enabled: true
    image:
      repository: postgres-exporter
      tag: 0.12.0-debian-11-r91
    resources:
      requests:
        cpu: "0.200"
        memory: 200Mi
      limits:
        cpu: "0.200"
        memory: 200Mi
    serviceMonitor:
      enabled: false
  host: postgres
  port: 5432

redis:
  image: redis:7.0.12-alpine3.18
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  host: redis
  port: 6379
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []

###########################
# Redis High Availability #
###########################

redisHa:
  ## Enable Redis HA Deployment
  ## Note: This is only to enable Redis HA deployment, to enable Redis Sentinel usage,
  ## please also set the variables below on "cognigyEnv" section: 
  ## "REDIS_SENTINEL_MASTER_NAME", "REDIS_SENTINEL_HOST", "REDIS_SENTINEL_PORT"
  enabled: false
  global:
    imagePullSecrets:
      - cognigy-registry-token
  fullnameOverride: "redis-ha"
  image:
    registry: cognigy.azurecr.io
    repository: redis
    tag: 7.0.10-debian-11-r8
  auth:
    enabled: false
    sentinel: false
  commonConfiguration: |-
    appendonly no
    protected-mode no
    repl-diskless-sync no
    save ""
    stop-writes-on-bgsave-error yes
    maxmemory-policy volatile-ttl
  replica:
    replicaCount: 3
    resources:
      requests:
        cpu: "0.150"
        memory: 300Mi
      limits:
        cpu: "0.150"
        memory: 300Mi
    priorityClassName: ""
    ## Set the maxmemory to the 85% of the redis memory limit.
    configuration: |-
      maxmemory 436mb
    podLabels:
      uniquezone: "redis-ha"
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: "uniquezone"
                  operator: In
                  values:
                    - "redis-ha"
            topologyKey: "topology.kubernetes.io/zone"
    persistence:
      enabled: false
  sentinel:
    enabled: true
    image:
      registry: cognigy.azurecr.io
      repository: redis-sentinel
      tag: 7.0.10-debian-11-r7
    automateClusterRecovery: true
    downAfterMilliseconds: 2000
    failoverTimeout: 10000
    resources:
      requests:
        cpu: "0.150"
        memory: 300Mi
      limits:
        cpu: "0.150"
        memory: 300Mi
  metrics:
    enabled: true
    image:
      registry: cognigy.azurecr.io
      repository: redis-exporter
      tag: 1.45.0-debian-11-r31
    resources:
      requests:
        cpu: "0.200"
        memory: 200Mi
      limits:
        cpu: "0.200"
        memory: 200Mi
    serviceMonitor:
      enabled: false

##############
# Monitoring #
##############

grafana:
  enabled: false
  image: grafana/grafana:9.1.8
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  storageClassName: grafana
  storage: 2Gi
  port: 3000

heplifyServer:
  ## The "latest" tag is the only one available
  image: cognigy.azurecr.io/vg-heplify:release-1071b4404ff17c8cee54fd118394fb058c7ad868-1689255787
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  serviceName: heplify-server
  ## This param specifies the number of days after which all data in the database (except logs) will be deleted automatically.
  dbDropDays: 14
  ## This param sets the number of days after which call-related data will be deleted from the database.
  dbDropDaysCall: 14
  ## This param indicate the number of days after which registration-related data will be dropped from the database.
  dbDropDaysRegister: 1
  ## This param specifies the number of days after which any other data that is not related to the above categories will be dropped from the database.
  dbDropDaysDefault: 1
  ports:
    tcp: 9096
    udp: 9060

homer:
  ## The "latest" tag is the only one available
  image: cognigy.azurecr.io/vg-homer:release-3fdeac08d35a6747920bba905d39a7fb4a59a79c-1689255776
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  serviceName: homer
  urlPrefixServiceConnection: http://
  ## Default credentials
  auth:
    username: admin
    password: sipcapture
  port: 80

jaeger:
  image: cognigy.azurecr.io/vg-jaeger:release-497502cd13b86f36afb2095997e903bc141e9e1d-1689255781
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  serviceName: jaeger
  urlPrefixServiceConnection: http://
  username: "jaeger_admin"
  password: "jaeger_password"
  existingSecret: ""
  ports:
    tcp: 16686
    udp:
      compact: 6831
      collector: 6832

metrics:
  port: 8002

health:
  port: 8001

telegraf:
  image: cognigy.azurecr.io/vg-telegraf:release-f560abcc37d6d01f49cb3dfd32668f94625cf8d9-1689255793
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  serviceName: telegraf
  port: 8125

## You can enable the pod monitor if any prometheus instance is running on your cluster.
podMonitors:
  enabled: false
  ## The namespace for the pod-monitor should be the same namespace where your prometheus instance is running
  namespace: "monitoring"


#################
# Cognigy Login #
#################

cognigyLogin:
  enabled: false
  baseUrl: ""
  clientId: "voicegateway"
  secret: "vg-cognigy-login"
  secretKey: "clientSecret"

###########################
# VoiceGateway Components #
###########################

jobs:
  image: cognigy.azurecr.io/vg-alpine-curl:release-3e40d054c558f45fd5b1746733e8bd8e1dc3c758-1694002229

api:
  image: cognigy.azurecr.io/api-server:release-672ea410515bc4589a4d120c261f8572c0410e5a-1701693511
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  logLevel: info
  port: 3000
  serviceName: api-server
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - api-server
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  ## Prefix used to create some endpoint values [http | https]
  jwtAuth: true
  enableDebounceMiddleware: true
  debounceTimeInSeconds: 5
  debounceQuantity: 50
  rateLimitMinutes: 4
  rateLimit: 400
  protocol: https
  resources:
    requests:
      cpu: "0.250"
      memory: 250Mi
    limits:
      cpu: "0.500"
      memory: 500Mi

apiBan:
  enabled: true
  image: cognigy.azurecr.io/api-ban:release-b682f058504507cd139f16eb54bbf82b9e823014-1700065274
  imagePullPolicy: IfNotPresent
  endpoint: https://apiban.org/api
  redisSetKey: apiban:ips
  refreshInterval: 3600
  cronjobTtlSecondsAfterFinished: 180
  apiKey:
    key: ""
    ## For existing API Key, the secret must have the following key:
    ## "apiKey": Containing API Key of API Ban
    ## NOTE: When apiKey.existingKey is set, the values in the previous parameter "apiKey.key" is ignored.
    existingKey: ""
  ## Add a list of known CIDRs to be banned, e.g.: "192.255.255.255/12, 168.255.255.255/24"
  bannedIpsList: ""
  cronjobSchedule: "0 * * * *"

billingApp:
  enabled: false
  image: cognigy.azurecr.io/voicegateway-billing-app:release-c492fb47adaa39d488c021986782db8e523e9206-1700065261
  imagePullPolicy: IfNotPresent
  replicasCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  port: 9000
  endpoint: ""
  endpointProtocol: "https"
  updateCallHistoryEndpointPath: "/api/v1/call-history/update"
  deactivateAccountEndpointPath: "/api/v1/account/deactivate"
  callHistoryTtlSecondsAfterFinished: 180
  deactivateTtlSecondsAfterFinished: 180
  billingAppUserCreds:
    user: ""
    password: ""
    ## For existing user info, the secret must have the following two keys:
    ## "user": Containing the username to log into api-server
    ## "password": Containing password of the above username
    ## NOTE: When billingApp.existingCredentials is set, the values in the previous parameters
    ## "billingApp.user" and "billingApp.password" are ignored.
    existingCredentials: ""
  resources:
    requests:
      cpu: "0.100"
      memory: 150Mi
    limits:
      cpu: "0.200"
      memory: 300Mi

drachtio:
  image: cognigy.azurecr.io/drachtio-server:release-58a8f8d16468bae2e6d1031474364b9a192aa2df-1700034936
  imagePullPolicy: IfNotPresent
  port: 9022
  homerId: 10
  resources:
    requests:
      cpu: "0.250"
      memory: 250Mi
    limits:
      cpu: "0.250"
      memory: 250Mi

featureServer:
  image: cognigy.azurecr.io/jambonz-feature-server:release-609f179a91fe3fb950081157bab888e50ce2d956-1701871053
  imagePullPolicy: Always
  replicaCount: 2
  logLevel: info
  trimTts: true
  serviceName: feature-server
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - feature-server
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  sigtermForceCloseTimeoutMs: ""
  terminationGracePeriodSeconds: 900
  ## Please set featureServer.useStatefulSet to false if you don't want to use StatefulSet for Feature Server (headless service)
  ## Setting it to false is not recommended and does not work if Azure cloud.
  useStatefulSet: true
  headlessServiceName: feature-server-headless
  freeswitchConnection: "127.0.0.1:8021:JambonzR0ck$"
  # Sets the max memory size of V8's old memory section - size in Megabytes
  nodeOptions: "--max-old-space-size=450"
  ports:
    tcp: 3000
    udp: 5060
  resources:
    requests:
      cpu: "1"
      memory: 500Mi
    limits:
      cpu: "1"
      memory: 500Mi

freeswitch:
  image: cognigy.azurecr.io/docker-drachtio-freeswitch-mrf:release-8ac433a7004b7d8ed0fe14137a38427320f373e8-1700035520
  imagePullPolicy: IfNotPresent
  logLevel: info
  ## Argument "--codec-answer-generous" is commented because we are looking into a DTMF recognition issue using Firefox, in the Interaction Panel Call,
  ## and until we don't have a solution we will force a specific codec for it. Once we have defintiive solution, we uncomment this.
  args:
    - freeswitch
    # - --codec-answer-generous
    - --username
    - Cognigy
    # - --sip-port 5080 (default: 5080)
    # - --tls-port 5081 (default: 5081)
    # - --event-socket-port 8081 (default: 8021)
  port: 8021
  resources:
    requests:
      cpu: "2.5"
      memory: 3Gi
    limits:
      cpu: "2.5"
      memory: 3Gi

rtpEngine:
  image: cognigy.azurecr.io/docker-rtpengine:release-be70cea88c549b07dd241f1a170ba42146e7d262-1692285009
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  logLevel: 5
  port: 22222
  homerId: 11
  resources:
    requests:
      cpu: "2"
      memory: 250Mi
    limits:
      cpu: "2"
      memory: 250Mi

rtpEngineSidecar:
  image: cognigy.azurecr.io/sbc-rtpengine-sidecar:release-efbd10d98da2514a9b4c3b2a1a889d2d5187a1cd-1700034906
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  logLevel: info
  ports:
    dtmf: 22223
  resources:
    requests:
      cpu: "0.100"
      memory: 200Mi
    limits:
      cpu: "0.100"
      memory: 200Mi

sbcCallRouter:
  image: cognigy.azurecr.io/sbc-call-router:release-70c89c82415645cbce389343bb2beecaa5c2cfba-1700034913
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - sbc-call-router
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  logLevel: info
  port: 3000
  resources:
    requests:
      cpu: "0.100"
      memory: 150Mi
    limits:
      cpu: "0.100"
      memory: 150Mi

sbcInbound:
  image: cognigy.azurecr.io/sbc-inbound:release-3ed4b26713edc88688ac1d03cd36c1d7b01926c7-1700034959
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - sbc-inbound
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  logLevel: info
  terminationGracePeriodSeconds: 900
  ## Enables Feature Server Signaling Transport as TCP, instead UDP (default)
  ##
  ## Note: This is an experimental feature. Please do not enable this in a production environment.
  ##
  featureServerSignalingTransportTcp: false
  ports:
    tcp: 4000
    dtmf: 22224
  serviceName: sbc-inbound
  resources:
    requests:
      cpu: "0.200"
      memory: 250Mi
    limits:
      cpu: "0.200"
      memory: 250Mi

sbcOutbound:
  image: cognigy.azurecr.io/sbc-outbound:release-5cf8a31cc6de03cb0adca77050ee4d48a841f977-1700034953
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - sbc-outbound
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  logLevel: info
  terminationGracePeriodSeconds: 900
  ports:
    tcp: 4000
    dtmf: 22225
  serviceName: sbc-outbound
  resources:
    requests:
      cpu: "0.150"
      memory: 150Mi
    limits:
      cpu: "0.150"
      memory: 150Mi
  padCrypto: false

sbcSipSidecar:
  image: cognigy.azurecr.io/sbc-sip-sidecar:release-0d47608674d471563acdeb758c5c59fdddcd844f-1701179645
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  logLevel: info
  resources:
    requests:
      cpu: "0.100"
      memory: 150Mi
    limits:
      cpu: "0.100"
      memory: 150Mi

testCallManager:
  enabled: false
  image: cognigy.azurecr.io/voicegateway-test-call-manager:release-02f50edc9db1b37cb97340df5a36f7ac49c20682-1700065268
  imagePullPolicy: IfNotPresent
  replicaCount: 1
  affinity: {}
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  port: 3000
  authEndpoint: ""
  authEndpointProtocol: "https"
  authEndpointPath: "/api/v1/call/auth"
  cronjobTtlSecondsAfterFinished: 180
  cleanUpEndpoint: ""
  cleanUpEndpointProtocol: "https"
  cleanUpEndpointPath: "/api/v1/call/clean-up"
  cleanUpThreshold:
    garbageCollection: 1800000 # 30 minutes
    recentCalls: 600000 # 10 minutes
  interactionPanelServiceProvider:
    id: ""
    apiKey: ""
    ## For existing service provider info, the secret must have the following two keys:
    ## "id": Containing the ID of the Service Provider
    ## "apiKey": Containing API Key of the above Service Provider
    ## NOTE: When interactionPanelServiceProvider.existingCredentials is set, the values in the previous parameters
    ## "interactionPanelServiceProvider.id" and "interactionPanelServiceProvider.apiKey" are ignored.
    existingCredentials: ""
  resources:
    requests:
      cpu: "0.100"
      memory: 200Mi
    limits:
      cpu: "0.200"
      memory: 400Mi

webapp:
  image: cognigy.azurecr.io/vg-webapp:release-67fddb855b0108a7122123a6a34e52c488db44ce-1702044646
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                  - webapp
            topologyKey: kubernetes.io/hostname
  nodeSelector: {}
  priorityClassName: ""
  podSecurityContext: {}
  tolerations: []
  port: 3001
  cognigyUrl: ""
  disableCallRecording: false
  disableCustomSpeech: false
  disableDefaultTrunkRouting: false
  disableTracing: false
  disableLcr: false
  disableSipClient: false
  disableSpLimits: false
  enableAccountLimits: true
  enableAllSpeechProviders: false
  enableCognigyLogin: false
  enableForgotPassword: false
  enableMsTeamsRouting: false
  enableSms: false
  resources:
    requests:
      cpu: "0.1"
      memory: 200Mi
    limits:
      cpu: "0.2"
      memory: 400Mi

###########
# Traefik #
###########

# The values below are used for Traefik Helm Chart
# For more information, see: https://github.com/traefik/traefik-helm-chart
traefik:
  enabled: true
  instanceLabelOverride: "voicegateway"
  fullnameOverride: traefik
  image:
    registry: cognigy.azurecr.io
    repository: traefik
    tag: "2.10.1"
    pullPolicy: IfNotPresent
  deployment:
    ## Specify imagePullSecrets to pull the image from private repository
    ## Based on the information provided in "imageCredentials" parameter previously, this should be either "cognigy-registry-token" or predefined secrets
    ## Note: Can be ignored if traefik is not enabled
    imagePullSecrets:
      - name: cognigy-registry-token
    replicas: 3
  logs:
    general:
      level: INFO
    access:
      enabled: true
      filters: {}
      fields:
        general:
          defaultmode: keep
          names: {}
        headers:
          defaultmode: drop
          names: {}
  ingressClass:
    enabled: true
    isDefaultClass: true
  ingressRoute:
    dashboard:
      enabled: false
  globalArguments:
    - "--api.insecure=true"
  additionalArguments: []
  ports:
    traefik:
      port: 9000
      expose: false
      exposedPort: 9000
      protocol: TCP
    web:
      port: 8000
      expose: true
      exposedPort: 80
      protocol: TCP
      ## Note: If traefik is enabled, and tls not, then the auto redirection of http to https also must be disabled
      ## Do that by setting traefik.ports.web.redirectTo: null
      redirectTo: websecure
      # Trust forwarded headers information (X-Forwarded-*).
      forwardedHeaders:
        trustedIPs: []
        insecure: true
      # Enable the Proxy Protocol header parsing for the entry point
      proxyProtocol:
        trustedIPs: []
        insecure: true
    websecure:
      port: 8443
      expose: true
      exposedPort: 443
      protocol: TCP
      # Trust forwarded  headers information (X-Forwarded-*).
      forwardedHeaders:
        trustedIPs: []
        insecure: true  
      # Enable the Proxy Protocol header parsing for the entry point
      proxyProtocol:
        trustedIPs: []
        insecure: true
      tls:
        enabled: true
        options: ""
        certResolver: ""
        domains: []
    metrics:
      port: 9100
      expose: false
      exposedPort: 9100
      protocol: TCP
  service:
    enabled: true
    type: LoadBalancer
    annotations: {}
    annotationsTCP: {}
    annotationsUDP: {}
    labels: {}
    spec: {}
    loadBalancerSourceRanges: []
    externalIPs: []
  tlsOptions:
    default:
      minVersion: VersionTLS12
      cipherSuites:
        - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
        - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
## For the SecurityContext config of traefik, please refer to the official values.yaml file of the traefik
## This is the link for chart v23.1.0 for example
## https://github.com/traefik/traefik-helm-chart/blob/6df869b8e8bcd6757e7934b554b97d925350c9fa/traefik/values.yaml#L882-L901


## Optionally create priorityClass
## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
##
priorityClass:
  enabled: true
  critical:
    enabled: true
    name: critical
    value: 4000000
    preemptionPolicy: PreemptLowerPriority
    globalDefault: false
    description: "PriorityClass for critical priority services"
  high:
    enabled: true
    name: high
    value: 3000000
    preemptionPolicy: PreemptLowerPriority
    globalDefault: false
    description: "PriorityClass for high priority services"
  medium:
    enabled: true
    name: medium
    value: 2000000
    preemptionPolicy: PreemptLowerPriority
    globalDefault: false
    description: "PriorityClass for medium priority services"
  low:
    enabled: true
    name: low
    value: 1000000
    preemptionPolicy: Never
    globalDefault: false
    description: "PriorityClass for low priority services"

